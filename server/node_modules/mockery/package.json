{
  "name": "mockery",
  "version": "1.4.0",
  "description": "Simplifying the use of mocks with Node.js",
  "keywords": [
    "mock",
    "stub",
    "require",
    "module",
    "cache",
    "unit",
    "test",
    "unittest",
    "testing",
    "tdd"
  ],
  "author": {
    "name": "Martin Cooper",
    "email": "mfncooper@gmail.com"
  },
  "contributors": [
    {
      "name": "Bryan Donovan",
      "email": "bdondo@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/mfncooper/mockery.git"
  },
  "bugs": {
    "url": "http://github.com/mfncooper/mockery/issues"
  },
  "main": "mockery.js",
  "engines": {
    "node": ">=0.4.5"
  },
  "dependencies": {},
  "devDependencies": {
    "nodeunit": "0.6.x",
    "sinon": "1.2.x"
  },
  "scripts": {
    "test": "test/run.js"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/mfncooper/mockery/raw/master/LICENSE"
    }
  ],
  "readme": "# Mockery - Simplifying the use of mocks with Node.js\n\n[![Build Status](https://secure.travis-ci.org/mfncooper/mockery.png)](http://travis-ci.org/mfncooper/mockery)\n\nIf you've tried working with mocks in Node.js, you've no doubt discovered that\nit's not so easy to get your mocks hooked up in the face of Node's module\nloading system. When your source-under-test pulls in its dependencies through\n`require`, you want your mocks provided, instead of the original module,\nto enable true unit testing of your code.\n\nThis is exactly the problem Mockery is designed to solve. Mockery gives you a\nsimple and easy to use API with which you can hook in your mocks without having\nto get your hands dirty with the `require` cache or other Node implementation\ndetails.\n\nMockery is *not* a mocking framework. It lets you work more easily with your\nframework of choice (or no framework) to get your mocks hooked in to all the\nright places in the code you need to test.\n\n## Installation\n\nJust use npm:\n\n    npm install mockery\n\n## Enabling mockery\n\nWhen enabled, Mockery intercepts *all* `require` calls, regardless of where\nthose calls are being made from. Thus it's almost always desirable to bracket\nyour usage as narrowly as possible.\n\nIf you're using a typical unit testing framework, you might enable and disable\nMockery in the test setup and teardown functions for your test cases. Something\nlike this:\n\n    setUp: function() {\n        mockery.enable();\n    },\n    tearDown: function() {\n        mockery.disable();\n    }\n\n### Options\n\nYou can set up some initial configuration by passing an options object to\n`enable`. Omitting the options object, or any of the defined keys, causes the\nstandard defaults to be used.\n\nFor example, to disable all warnings, you might use this:\n\n    mockery.enable({\n        warnOnReplace: false,\n        warnOnUnregistered: false\n    });\n\nThe available options are:\n\n* _useCleanCache_ determines whether a temporary module cache should be used\nwhile Mockery is enabled. See [Controlling the module cache](#controlling-the-module-cache)\nbelow. [Default: false]\n* _warnOnReplace_ determines whether or not warnings are issued when a mock or\nsubstitute is replaced without being first deregistered. This has the same\neffect as the `warnOnReplace` function. [Default: true]\n* _warnOnUnregistered_ determines whether or not warnings are issued when a\nmodule is not mocked, substituted or allowed. This has the same effect as the\n`warnOnUnregistered` function. [Default: true]\n\n## Registering mocks\n\nYou register your mocks with Mockery to tell it which mocks to provide for which\n`require` calls. For example:\n\n    var fsMock = {\n        stat: function (path, cb) { /* your mock code */ }\n    };\n    mockery.registerMock('fs', fsMock);\n\nThe arguments to `registerMock` are as follows:\n\n* _module_, the name or path of the module for which a mock is being\nregistered. This must exactly match the argument to `require`; there is no\n\"clever\" matching.\n* _mock_, the mock to be provided. Whatever is provided here is what will\nbecome the result of subsequent `require` calls; that is, the `exports` of the\nmodule.\n\nIf you no longer want your mock to be used, you can deregister it:\n\n    mockery.deregisterMock('fs');\n\nNow the original module will be provided for any subsequent `require` calls.\n\n## Registering substitutes\n\nSometimes you want to implement your mock itself as a module, especially if it's\nmore complicated and you'll be reusing it more widely. In that case, you can\ntell Mockery to substitute that module for the original one. For example:\n\n    mockery.registerSubstitute('fs', 'fs-mock');\n\nNow any `require` invocation for 'fs' will be satisfied by loading the 'fs-mock'\nmodule instead.\n\nThe arguments to `registerSubstitute` are as follows:\n\n* _module_, the name or path of the module for which a substitute is being\nregistered. This must exactly match the argument to `require`; there is no\n\"clever\" matching.\n* _substitute_, the name or path of the module to substitute for _module_.\n\nIf you no longer want your substitute to be used, you can deregister it:\n\n    mockery.deregisterSubstitute('fs');\n\nNow the original module will be provided for any subsequent `require` calls.\n\n## Registering allowable modules\n\nIf you enable Mockery and _don't_ mock or substitute a module that is later\nloaded via `require`, Mockery will print a warning to the console to tell you\nthat. This is so that you don't inadvertently use downstream modules without\nbeing aware of them. By registering a module as \"allowable\", you tell Mockery\nthat you know about its use, and then Mockery won't print the warning.\n\nThe most common use case for this is your source-under-test, which obviously\nyou'll want to load without warnings. For example:\n\n    mockery.registerAllowable('./my-source-under-test');\n\nAs with `registerMock` and `registerSubstitute`, the first argument, _module_,\nis the name or path of the module as it would be provided to `require`. Once\nagain, you can deregister it if you need to:\n\n    mockery.deregisterAllowable('./my-source-under-test');\n\nSometimes you'll find that you need to register several modules at once. A\nconvenience function lets you do this with a single call:\n\n    mockery.registerAllowables(['async', 'path', 'util']);\n\nand similarly to deregister several modules at once, as you would expect:\n\n    mockery.deregisterAllowables(['async', 'path', 'util']);\n\n### Unhooking\n\nBy default, the Node module loader will load a given module only once, caching\nthe loaded module for the lifetime of the process. When you're using Mockery,\nthis is almost always what you want. _Almost_. In relatively rare situations,\nyou may find that you need to use different mocks for different test cases\nfor the same source-under-test. (This is not the same as supplying different\ntest data in the same mock; here we're talking about providing different\nfunctions for a module's `exports`.)\n\nTo do this, your source-under-test must be unhooked from Node's module loading\nsystem, such that it can be loaded again with new mocks. You do this by passing\na second argument, _unhook_, to `registerAllowable`, like this:\n\n    mockery.registerAllowable('./my-source-under-test', true);\n\nWhen you subsequently deregister your source-under-test, Mockery will unhook it\nfrom the Node module loading system as well as deregistering it.\n\n## Deregistering everything\n\nSince it's such a common use case, especially when you're using a unit test\nframework and its setup and teardown functions, Mockery provides a convenience\nfunction to deregister everything:\n\n    mockery.deregisterAll();\n\nThis will deregister all mocks, substitutes, and allowable modules, as well as\nunhooking any hooked modules.\n\n## Controlling the module cache\n\nOne of the common problems that people encounter when trying to use mocks in\nNode is that modules and their exports are almost always cached. This makes it\ndifficult to plug in a mock for testing if the module being mocked has already\nbeen loaded elsewhere.\n\nMockery provides a way for you to run your tests using a clean module cache, as\nif no modules have been loaded. When this option is enabled, any previously\nloaded modules will be \"forgotten\", and `require` calls will cause them to be\nreloaded. This in turn allows your mocks to be picked up, and your tests to run\nas expected.\n\nYou tell Mockery to use a clean cache when you enable it, like this:\n\n    mockery.enable({ useCleanCache: true });\n\nNow all modules will be cached in this new clean cache, until you later disable\nMockery again. The new cache is temporary, and is discarded when Mockery is\ndisabled. The original cache is reinstated at that point, so you are back to\nwhere you were before enabling the clean cache option.\n\nWhile you are working with a temporary cache, it may occasionally be useful to\nreset it to a clean state again, without disabling and re-enabling Mockery. You\ncan do this with:\n\n    mockery.resetCache();\n\nThis function has no effect if the clean cache option is not already in use.\n\n## Disabling warnings\n\nAs mentioned above, if you enable Mockery and _don't_ mock, substitute, or\nallow a module that is later loaded, Mockery will print a warning to the\nconsole to tell you that. This is important when you're writing unit tests,\nso that you don't end up using modules you weren't aware of.\n\nIn certain circumstances, such as when writing functional or integration tests,\nyou may find it irritating to have to allow each module or to have all the\nwarnings appear on the console. If you need to, you can tell Mockery to turn\noff those warnings:\n\n    mockery.warnOnUnregistered(false);\n\nMockery will also print a warning to the console whenever you register a mock\nor substitute for a module for which one is already registered. This is almost\nalways what you want, since you should be deregistering mocks and substitutes\nthat you no longer need. Occasionally, though, you may want to suppress these\nwarnings, which you can do like this:\n\n    mockery.warnOnReplace(false);\n\nIn either of these cases, if you later need to re-enable the warnings, then\npassing `true` to the same functions will do that, as you might imagine.\n\n## The name\n\nMockery is to mocks as rookery is to rooks.\n\n## License\n\nMockery is licensed under the [MIT License](http://github.com/mfncooper/mockery/raw/master/LICENSE).\n",
  "readmeFilename": "README.md",
  "_id": "mockery@1.4.0",
  "_from": "mockery@"
}
